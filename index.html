<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>명탐정 코난 시청 기록 관리</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        /* 커스텀 스크롤바 */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        /* 아코디언 콘텐츠 전환 효과 */
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .accordion-content.open {
            max-height: 2000px; /* 충분히 큰 값 */
            transition: max-height 0.5s ease-in;
        }

        /* 커스텀 체크박스 */
        .custom-checkbox:checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
        }
        .custom-checkbox:checked::before {
            content: '✔';
            color: white;
            font-size: 12px;
            line-height: 16px;
            text-align: center;
            display: block;
        }
        
        /* 국기 버튼 스타일 (GitHub Raw URL 사용) */
        .btn-inactive {
            background-color: #e5e7eb; /* gray-200 */
            color: #4b5563; /* gray-600 */
        }
        .btn-kr-active {
            background-image: url("https://raw.githubusercontent.com/ksh3kim/project-img/main/korean.png");
            background-size: cover;
            background-position: center;
            color: white;
            text-shadow: 0 0 4px black;
        }
        .btn-jp-active {
            background-image: url("https://raw.githubusercontent.com/ksh3kim/project-img/main/japanese.png");
            background-size: cover;
            background-position: center;
            color: white;
            text-shadow: 0 0 4px black;
        }
        
        /* 활성화된 탭 스타일 */
        .view-tab.active {
            border-bottom-color: #3b82f6;
            color: #3b82f6;
            font-weight: 600;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div id="app" class="max-w-2xl mx-auto bg-white min-h-screen shadow-lg flex flex-col">
        <div class="flex-grow">
            <!-- 헤더 -->
            <header class="sticky top-0 bg-white/80 backdrop-blur-sm z-10 p-4 border-b flex justify-between items-center">
                <img src="https://raw.githubusercontent.com/ksh3kim/project-img/main/Regulus_logo.png" alt="Logo" class="h-12">
                <div class="flex items-center space-x-2">
                    <!-- [수정] 버튼 크기 클래스 변경 -->
                    <button id="kr-btn" class="px-3 py-1 text-sm font-semibold rounded-full shadow-sm transition-all"></button>
                    <button id="jp-btn" class="px-3 py-1 text-sm font-semibold rounded-full shadow-sm transition-all"></button>
                    <button id="reset-btn" title="시청 기록 초기화" class="px-3 py-1 text-sm font-semibold text-gray-600 bg-gray-200 rounded-full shadow-sm">
                        <i class="fa-solid fa-rotate-right"></i>
                    </button>
                </div>
            </header>

            <!-- 제목 섹션 -->
            <div class="bg-white p-3 border-b">
                <h1 class="text-center text-xl font-bold text-gray-800">명탐정 코난 시청 기록 관리매니저</h1>
            </div>

            <!-- TV 시리즈 / 극장판 탭 -->
            <div class="bg-white border-b flex">
                <button data-view-type="tv" class="view-tab flex-1 py-2 text-center text-gray-500 border-b-2 border-transparent">TV 시리즈</button>
                <button data-view-type="movie" class="view-tab flex-1 py-2 text-center text-gray-500 border-b-2 border-transparent">극장판 & 스페셜</button>
            </div>

            <!-- 컨트롤 패널 -->
            <div class="p-4 bg-gray-50 border-b space-y-4">
                <div class="relative">
                    <input type="text" id="search-bar" placeholder="제목으로 검색..." class="w-full p-2 pl-8 border rounded-md focus:ring-2 focus:ring-blue-500">
                    <i class="fa-solid fa-search absolute left-2.5 top-2.5 text-gray-400"></i>
                </div>

                <div class="flex space-x-2">
                    <button data-filter="all" class="filter-btn w-1/3 px-4 py-2 text-sm font-medium rounded-md shadow-sm">전체</button>
                    <button data-filter="watched" class="filter-btn w-1/3 px-4 py-2 text-sm font-medium rounded-md shadow-sm">시청</button>
                    <button data-filter="unwatched" class="filter-btn w-1/3 px-4 py-2 text-sm font-medium rounded-md shadow-sm">미시청</button>
                </div>
                
                <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
                    <button id="add-episode-toggle" class="w-full text-left p-2 bg-gray-200 rounded-md text-sm font-semibold text-gray-700">
                        <!-- 텍스트는 JS로 동적 변경 -->
                    </button>
                    <div class="relative" id="export-container">
                        <button id="export-btn-toggle" class="w-full p-2 bg-green-500 text-white rounded-md text-sm font-semibold">
                            <i class="fa-solid fa-file-export mr-1"></i>내보내기
                        </button>
                        <div id="export-options" class="hidden absolute right-0 mt-2 w-full bg-white rounded-md shadow-lg z-10">
                            <a href="#" data-format="csv" class="export-format-btn block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">CSV로 저장</a>
                            <a href="#" data-format="txt" class="export-format-btn block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">TXT로 저장</a>
                        </div>
                    </div>
                    <button id="import-btn" class="w-full p-2 bg-blue-500 text-white rounded-md text-sm font-semibold">
                        <i class="fa-solid fa-file-import mr-1"></i>가져오기
                    </button>
                    <input type="file" id="import-file-input" class="hidden" accept=".json,.csv,.txt,.xlsx">
                </div>

                <!-- 새 회차 추가 폼 -->
                <div id="add-episode-form" class="hidden p-3 bg-white border rounded-md text-sm">
                    <!-- TV 시리즈용 입력 필드 -->
                    <div id="add-tv-fields" class="grid grid-cols-2 gap-2">
                        <input type="number" id="new-jp-ep" placeholder="일본판 화수" class="p-1 border rounded-md w-full text-xs">
                        <input type="text" id="new-kr-ep-str" placeholder="한국판 화수 (예: 1-1)" class="p-1 border rounded-md w-full text-xs">
                    </div>
                    <!-- 극장판용 입력 필드 -->
                    <div id="add-movie-fields" class="hidden grid-cols-2 gap-2">
                         <input type="number" id="new-movie-order" placeholder="작품 순서 (예: 1)" class="p-1 border rounded-md w-full text-xs">
                         <input type="text" id="new-movie-season" placeholder="시즌명 (예: 1기)" class="p-1 border rounded-md w-full text-xs">
                    </div>
                    <!-- 공통 입력 필드 -->
                    <input type="text" id="new-title" placeholder="제목" class="mt-2 p-1 border rounded-md w-full text-xs">
                    <select id="new-category" class="mt-2 p-1 border rounded-md w-full text-xs">
                        <!-- 옵션은 JS로 동적 변경 -->
                    </select>
                    <button id="add-episode-btn" class="mt-2 w-full px-4 py-1 font-semibold text-white bg-blue-500 rounded-md hover:bg-blue-600">추가</button>
                </div>
            </div>

            <main id="episode-list" class="p-4 space-y-2">
                <!-- 에피소드 렌더링 영역 -->
            </main>
        </div>

        <footer class="p-4 bg-gray-100 border-t mt-auto">
            <div id="edit-mode-controls" class="text-center space-y-2">
                <button id="edit-mode-toggle" class="px-4 py-2 text-sm font-semibold text-white bg-gray-600 rounded-md shadow-sm hover:bg-gray-700">
                    <i class="fa-solid fa-gear"></i> 편집 모드 시작
                </button>
                <div id="danger-zone" class="hidden p-4 bg-red-50 border border-red-200 rounded-md space-y-2">
                    <p class="text-sm text-red-700 font-bold">주의: 삭제 작업은 되돌릴 수 없습니다.</p>
                    <button id="delete-all-btn" class="w-full px-4 py-2 text-sm font-semibold text-white bg-red-600 rounded-md shadow-sm hover:bg-red-700">
                        <i class="fa-solid fa-triangle-exclamation"></i> 모든 에피소드 삭제
                    </button>
                </div>
            </div>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const initialEpisodes = [];
            let currentListType = 'tv'; 
            let episodes = [];
            let currentView = 'kr';
            let currentFilter = 'all';
            let searchTerm = '';
            let openSeasons = new Set();
            let isEditMode = false;

            // [수정] 카테고리별 색상 맵
            const categoryColors = {
                '일반': '#FFFFFF',
                '검은조직': '#000000',
                '스페셜': '#E5F8F4',
                '아카이': '#AD2633',
                '경찰': '#222888',
                '괴도키드': '#B0C4DE',
                '극장판': '#FFD705',
            };

            const viewTabs = document.querySelectorAll('.view-tab');
            const addTvFields = document.getElementById('add-tv-fields');
            const addMovieFields = document.getElementById('add-movie-fields');
            const newCategorySelect = document.getElementById('new-category');
            
            const episodeListContainer = document.getElementById('episode-list');
            const krBtn = document.getElementById('kr-btn');
            const jpBtn = document.getElementById('jp-btn');
            const resetBtn = document.getElementById('reset-btn');
            const searchBar = document.getElementById('search-bar');
            const filterBtns = document.querySelectorAll('.filter-btn');
            const addEpisodeToggle = document.getElementById('add-episode-toggle');
            const addEpisodeForm = document.getElementById('add-episode-form');
            const addEpisodeBtn = document.getElementById('add-episode-btn');
            const exportBtnToggle = document.getElementById('export-btn-toggle');
            const exportOptions = document.getElementById('export-options');
            const importBtn = document.getElementById('import-btn');
            const importFileInput = document.getElementById('import-file-input');
            const editModeToggle = document.getElementById('edit-mode-toggle');
            const dangerZone = document.getElementById('danger-zone');
            const deleteAllBtn = document.getElementById('delete-all-btn');

            function saveData() {
                const dataToSave = { episodes, openSeasons: Array.from(openSeasons) };
                localStorage.setItem('conanAppState_v6', JSON.stringify(dataToSave));
            }

            function loadData() {
                const savedState = localStorage.getItem('conanAppState_v6');
                if (savedState) {
                    const loadedState = JSON.parse(savedState);
                    episodes = loadedState.episodes || initialEpisodes;
                    openSeasons = new Set(loadedState.openSeasons || []);
                } else {
                    episodes = initialEpisodes;
                }
                episodes.sort((a, b) => (a.jp_ep || 0) - (b.jp_ep || 0));
            }

            function render() {
                let baseList = episodes.filter(ep => (ep.type || 'tv') === currentListType);
                
                let episodesToRender = [...baseList];
                if (searchTerm) { episodesToRender = episodesToRender.filter(ep => ep.title.toLowerCase().includes(searchTerm.toLowerCase())); }
                if (currentFilter === 'watched') { episodesToRender = episodesToRender.filter(e => e.watched); } 
                else if (currentFilter === 'unwatched') { episodesToRender = episodesToRender.filter(e => !e.watched); }

                episodeListContainer.innerHTML = '';
                if (episodesToRender.length === 0) {
                    episodeListContainer.innerHTML = `<p class="text-center text-gray-500 py-8">표시할 항목이 없습니다.<br>새 항목을 추가하거나 데이터를 가져오세요.</p>`;
                } else {
                    if (currentListType === 'tv' && currentView === 'kr') { 
                        renderKoreanView(episodesToRender); 
                    } else { 
                        renderSimpleListView(episodesToRender); 
                    }
                }
                
                updateViewButtons();
                updateFilterButtons();
                updateEditModeUI();
                updateActiveListTypeTab();
            }
            
            function renderKoreanView(episodesToRender) {
                const seasons = episodesToRender.reduce((acc, ep) => {
                    const seasonKey = `${ep.kr_prefix || ''}${ep.kr_season}`;
                    if (!acc[seasonKey]) acc[seasonKey] = [];
                    acc[seasonKey].push(ep);
                    return acc;
                }, {});

                Object.keys(seasons).sort((a, b) => {
                    const aNum = parseInt(a.replace(/[^0-9]/g, ''), 10);
                    const bNum = parseInt(b.replace(/[^0-9]/g, ''), 10);
                    if (a.startsWith('애X') && !b.startsWith('애X')) return 1;
                    if (!a.startsWith('애X') && b.startsWith('애X')) return -1;
                    return aNum - bNum;
                }).forEach(seasonKey => {
                    const seasonEpisodes = seasons[seasonKey].sort((a,b) => a.kr_ep - b.kr_ep);
                    const seasonContainer = document.createElement('div');
                    seasonContainer.className = 'bg-white rounded-lg shadow-sm border';
                    
                    const firstEp = seasonEpisodes[0];
                    const allOriginalEpisodesInSeason = episodes.filter(e => `${e.kr_prefix || ''}${e.kr_season}` === seasonKey);
                    const allWatchedInSeason = allOriginalEpisodesInSeason.every(e => e.watched);
                    const isSeasonOpen = openSeasons.has(seasonKey);

                    let seasonTitle = `시즌 ${firstEp.kr_season}`;
                    if (firstEp.kr_prefix === '애X') {
                        seasonTitle = `애니박스 미공개 X파일 시즌${firstEp.kr_season}`;
                    }
                    
                    const header = document.createElement('div');
                    header.className = 'p-3 flex justify-between items-center cursor-pointer';
                    header.dataset.seasonKey = seasonKey;
                    header.innerHTML = `
                        <div class="flex items-center"><h2 class="font-bold text-lg text-gray-800">${seasonTitle}</h2><span class="ml-2 text-sm text-gray-500">(${seasonEpisodes.length}개)</span></div>
                        <div class="flex items-center space-x-3"><label class="flex items-center space-x-1 text-xs cursor-pointer"><span>전체선택</span><input type="checkbox" class="season-check w-4 h-4" data-season-key="${seasonKey}" ${allWatchedInSeason ? 'checked' : ''}></label><i class="fa-solid fa-chevron-down transition-transform ${isSeasonOpen ? 'rotate-180' : ''}"></i></div>
                    `;
                    
                    const content = document.createElement('div');
                    content.className = `accordion-content border-t ${isSeasonOpen ? 'open' : ''}`;
                    seasonEpisodes.forEach(ep => content.appendChild(createEpisodeElement(ep)));
                    seasonContainer.append(header, content);
                    episodeListContainer.appendChild(seasonContainer);
                });
            }

            function renderSimpleListView(episodesToRender) {
                episodesToRender.forEach(ep => episodeListContainer.appendChild(createEpisodeElement(ep)));
            }

            function createEpisodeElement(ep) {
                const el = document.createElement('div');
                el.className = 'flex items-center justify-between p-3 bg-gray-50 rounded-md hover:bg-gray-100';
                el.dataset.id = ep.id;

                let primaryLabel = '';
                let secondaryLabel = '';

                if (ep.type === 'movie') {
                    primaryLabel = ep.title;
                    secondaryLabel = ep.kr_ep_str || '';
                } else {
                    primaryLabel = ep.title;
                    if (currentView === 'jp') {
                        secondaryLabel = `${ep.jp_ep}화`;
                    } else {
                        secondaryLabel = (ep.kr_prefix === '애X') 
                            ? `애니박스 미공개 X파일 시즌${ep.kr_season}-${ep.kr_ep}화`
                            : `시즌${ep.kr_season}-${ep.kr_ep}화`;
                    }
                }
                
                const category = ep.category || (ep.type === 'movie' ? '극장판' : '일반');
                const bgColor = categoryColors[category] || '#FFFFFF';

                const deleteButtonHTML = isEditMode ? `
                    <button data-id="${ep.id}" class="delete-episode-btn text-red-500 hover:text-red-700 ml-4" title="이 항목 삭제">
                        <i class="fa-solid fa-trash-can"></i>
                    </button>
                ` : '';

                el.innerHTML = `
                    <div class="flex items-center flex-grow">
                        <input type="checkbox" data-id="${ep.id}" class="episode-check custom-checkbox w-4 h-4 mr-4 rounded border-gray-300 focus:ring-blue-500" ${ep.watched ? 'checked' : ''}>
                        <div class="flex-grow">
                            <p class="font-semibold text-gray-800">${primaryLabel}</p>
                            <p class="text-sm text-gray-500">${secondaryLabel}</p>
                        </div>
                    </div>
                    <div class="flex items-center">
                         <span class="text-sm font-mono px-2 py-1 rounded" style="background-color: ${bgColor}; color: ${getContrastYIQ(bgColor)}">${category}</span>
                        ${deleteButtonHTML}
                    </div>
                `;
                return el;
            }
            
            function getContrastYIQ(hexcolor){
                if(!hexcolor) return 'black';
                hexcolor = hexcolor.replace("#", "");
                if(hexcolor.length === 3) {
                    hexcolor = hexcolor.split('').map(char => char + char).join('');
                }
                if(hexcolor.length !== 6) return 'black';
                var r = parseInt(hexcolor.substr(0,2),16);
                var g = parseInt(hexcolor.substr(2,2),16);
                var b = parseInt(hexcolor.substr(4,2),16);
                var yiq = ((r*299)+(g*587)+(b*114))/1000;
                return (yiq >= 128) ? 'black' : 'white';
            }

            // [수정] 버튼 크기 클래스 복원
            function updateViewButtons() {
                const isTV = currentListType === 'tv';
                krBtn.style.display = isTV ? 'block' : 'none';
                jpBtn.style.display = isTV ? 'block' : 'none';

                if (isTV) {
                    krBtn.textContent = '한국판';
                    jpBtn.textContent = '일본판';
                    krBtn.className = 'px-3 py-1 text-sm font-semibold rounded-full shadow-sm transition-all ';
                    jpBtn.className = 'px-3 py-1 text-sm font-semibold rounded-full shadow-sm transition-all ';

                    if (currentView === 'kr') {
                        krBtn.classList.add('btn-kr-active');
                        jpBtn.classList.add('btn-inactive');
                    } else {
                        jpBtn.classList.add('btn-jp-active');
                        krBtn.classList.add('btn-inactive');
                    }
                }
            }

            function updateFilterButtons() {
                filterBtns.forEach(btn => {
                    btn.classList.remove('bg-gray-700', 'text-white', 'bg-white', 'text-gray-700');
                    if (btn.dataset.filter === currentFilter) {
                        btn.classList.add('bg-gray-700', 'text-white');
                    } else {
                        btn.classList.add('bg-white', 'text-gray-700');
                    }
                });
            }
            
            function updateActiveListTypeTab() {
                viewTabs.forEach(tab => {
                    if (tab.dataset.viewType === currentListType) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });
            }

            function updateEditModeUI() {
                if (isEditMode) {
                    editModeToggle.innerHTML = `<i class="fa-solid fa-check"></i> 편집 모드 종료`;
                    editModeToggle.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                    editModeToggle.classList.add('bg-blue-600', 'hover:bg-blue-700');
                    dangerZone.classList.remove('hidden');
                } else {
                    editModeToggle.innerHTML = `<i class="fa-solid fa-gear"></i> 편집 모드 시작`;
                    editModeToggle.classList.add('bg-gray-600', 'hover:bg-gray-700');
                    editModeToggle.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    dangerZone.classList.add('hidden');
                }
            }
            
            function updateAddFormUI() {
                let options = '';
                if (currentListType === 'tv') {
                    addTvFields.style.display = 'grid';
                    addMovieFields.style.display = 'none';
                    addEpisodeToggle.innerHTML = `<i class="fa-solid fa-plus mr-1"></i>새 에피소드 추가`;
                    options = `
                        <option value="일반">일반</option>
                        <option value="검은조직">검은조직</option>
                        <option value="스페셜">스페셜</option>
                        <option value="아카이">아카이</option>
                        <option value="경찰">경찰</option>
                        <option value="괴도키드">괴도키드</option>
                    `;
                } else { // movie
                    addTvFields.style.display = 'none';
                    addMovieFields.style.display = 'grid';
                    addEpisodeToggle.innerHTML = `<i class="fa-solid fa-plus mr-1"></i>새 극장판 추가`;
                    options = `
                        <option value="극장판">극장판</option>
                        <option value="스페셜">스페셜</option>
                    `;
                }
                newCategorySelect.innerHTML = options;
            }

            function handleReset() {
                if (confirm('정말로 모든 시청 기록을 초기화하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                    episodes.forEach(ep => { ep.watched = false; });
                    saveData();
                    render();
                }
            }
            
            function handleExport(format) {
                if (episodes.length === 0) {
                    alert('내보낼 데이터가 없습니다.');
                    return;
                }

                const fileExtension = format.toLowerCase();
                const tvHeader = "일본판 화수|한국판 화수|제목|에피소드 분류 키워드|시청 상태";
                const movieHeader = "분류|제목|시즌명|작품 순서|시청 상태";

                const tvRows = episodes.filter(ep => ep.type === 'tv').map(ep => {
                    return [ep.jp_ep, ep.kr_ep_str, ep.title, ep.category, ep.watched].join('|');
                });
                
                const movieRows = episodes.filter(ep => ep.type === 'movie').map(ep => {
                    return [ep.category, ep.title, ep.kr_ep_str, ep.movie_order, ep.watched].join('|');
                });

                const content = [tvHeader, ...tvRows, ...movieRows].join('\n');
                const blob = new Blob([`\uFEFF${content}`], { type: `text/${fileExtension};charset=utf-8;` });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                const date = new Date().toISOString().slice(0, 10);
                link.download = `conan-progress-${date}.${fileExtension}`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }

            function handleImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                const fileExtension = file.name.split('.').pop().toLowerCase();

                reader.onload = (e) => {
                    try {
                        let importedEpisodes = [];

                        if (fileExtension === 'json') {
                             const importedData = JSON.parse(e.target.result);
                            if (importedData.episodes && Array.isArray(importedData.episodes)) {
                                importedEpisodes = importedData.episodes;
                            } else {
                                throw new Error("이전 버전의 백업 파일(JSON)만 지원됩니다.");
                            }
                        } else if (fileExtension === 'csv' || fileExtension === 'txt' || fileExtension === 'xlsx') {
                            let lines;
                            if (fileExtension === 'xlsx') {
                                const workbook = XLSX.read(e.target.result, { type: 'array' });
                                const sheetName = workbook.SheetNames[0];
                                const worksheet = workbook.Sheets[sheetName];
                                lines = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                            } else {
                                lines = e.target.result.split(/\r?\n/).map(line => line.split('|'));
                            }
                            
                            if (lines.length > 0 && String(lines[0][0]).includes("일본판 화수")) {
                                lines.shift(); 
                            }
                            importedEpisodes = parseCustomFormat(lines);
                        } else {
                            throw new Error('지원하지 않는 파일 형식입니다.');
                        }

                        if (importedEpisodes.length > 0) {
                            if (confirm(`총 ${importedEpisodes.length}개의 항목을 가져옵니다. 현재 목록을 덮어쓰시겠습니까?`)) {
                                episodes = importedEpisodes;
                                openSeasons = new Set(); 
                                episodes.sort((a, b) => (a.jp_ep || 0) - (b.jp_ep || 0));
                                saveData();
                                render();
                                alert('성공적으로 데이터를 가져왔습니다.');
                            }
                        } else {
                            throw new Error('가져올 유효한 데이터가 없습니다.');
                        }

                    } catch (error) {
                        console.error(error);
                        alert(`파일을 가져오는 데 실패했습니다: ${error.message}`);
                    } finally {
                        importFileInput.value = '';
                    }
                };
                
                if (fileExtension === 'xlsx') {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file, 'UTF-8');
                }
            }
            
            function parseCustomFormat(data) {
                return data.map(rowArray => {
                    const firstItem = String(rowArray[0]).trim();
                    
                    if (firstItem === '극장판' || firstItem === '스페셜') {
                        const [category, title, seasonName, order, watched] = rowArray;
                        const movie_order = parseInt(order, 10);
                        return {
                            type: 'movie',
                            id: `movie-${movie_order}`,
                            movie_order: movie_order,
                            jp_ep: 20000 + movie_order,
                            kr_ep_str: seasonName,
                            title: title || '제목 없음',
                            category: category,
                            colorCode: categoryColors[category] || '#FFFFFF',
                            watched: String(watched).toLowerCase() === 'true'
                        };
                    } else {
                        const [jp_ep_str, kr_ep_str, title, category, watched] = rowArray;
                        const jp_ep = parseInt(jp_ep_str, 10);
                        const parsedKr = parseKoreanEpisodeString(kr_ep_str || '0-0');
                        return {
                            type: 'tv',
                            id: `jp-${jp_ep}`,
                            jp_ep: jp_ep,
                            kr_ep_str: kr_ep_str,
                            kr_season: parsedKr.season,
                            kr_ep: parsedKr.episode,
                            kr_prefix: parsedKr.prefix,
                            title: title || '제목 없음',
                            category: category || '일반',
                            colorCode: categoryColors[category || '일반'] || '#FFFFFF',
                            watched: String(watched).toLowerCase() === 'true'
                        };
                    }
                }).filter(item => item && item.id && (!isNaN(item.jp_ep) || !isNaN(item.movie_order)));
            }
            
            function parseKoreanEpisodeString(kr_ep_str) {
                const match = kr_ep_str.match(/^(애X)?(\d+)-(\d+)$/);
                if (match) {
                    return {
                        prefix: match[1] || '',
                        season: parseInt(match[2], 10),
                        episode: parseInt(match[3], 10)
                    };
                }
                return { prefix: '', season: 0, episode: 0 };
            }
            
            function handleViewChange(view) { currentView = view; render(); }
            function handleFilterChange(filter) { currentFilter = filter; render(); }

            function handleEpisodeCheck(id, checked) {
                const episode = episodes.find(e => e.id === id);
                if (episode) {
                    episode.watched = checked;
                    saveData();
                    if (currentFilter !== 'all' || searchTerm) { render(); } else {
                        const checkboxInList = episodeListContainer.querySelector(`.episode-check[data-id="${id}"]`);
                        if(checkboxInList) checkboxInList.checked = checked;
                        
                        if (episode.type === 'tv') {
                            const seasonKey = `${episode.kr_prefix || ''}${episode.kr_season}`;
                            const allOriginalEpisodesInSeason = episodes.filter(e => `${e.kr_prefix || ''}${e.kr_season}` === seasonKey);
                            const allWatchedInSeason = allOriginalEpisodesInSeason.every(e => e.watched);
                            const seasonCheckbox = episodeListContainer.querySelector(`.season-check[data-season-key="${seasonKey}"]`);
                            if(seasonCheckbox) seasonCheckbox.checked = allWatchedInSeason;
                        }
                    }
                }
            }
            
            function handleSeasonCheck(seasonKey, checked) {
                episodes.forEach(ep => { 
                    if (ep.type === 'tv') {
                        const currentKey = `${ep.kr_prefix || ''}${ep.kr_season}`;
                        if (currentKey === seasonKey) {
                            ep.watched = checked;
                        }
                    }
                });
                saveData();
                render();
            }

            function handleAccordionToggle(seasonKey) {
                if (openSeasons.has(seasonKey)) openSeasons.delete(seasonKey);
                else openSeasons.add(seasonKey);
                saveData();
                const header = episodeListContainer.querySelector(`.p-3[data-season-key="${seasonKey}"]`);
                if(header) {
                    header.querySelector('.fa-chevron-down').classList.toggle('rotate-180');
                    header.nextElementSibling.classList.toggle('open');
                }
            }
            
            function handleAddEpisode() { 
                const title = document.getElementById('new-title').value.trim();
                const category = newCategorySelect.value;
                if (!title) {
                    alert('제목을 입력해주세요.');
                    return;
                }

                let newEpisode = {
                    title: title,
                    category: category,
                    watched: false,
                    colorCode: categoryColors[category] || '#FFFFFF'
                };

                if (currentListType === 'tv') {
                    const jp_ep = parseInt(document.getElementById('new-jp-ep').value);
                    const kr_ep_str = document.getElementById('new-kr-ep-str').value.trim();
                    if (!jp_ep || !kr_ep_str) {
                        alert('TV 시리즈 정보를 모두 입력해주세요.');
                        return;
                    }
                    const parsedKr = parseKoreanEpisodeString(kr_ep_str);
                    if (parsedKr.season === 0 && parsedKr.episode === 0 && kr_ep_str !== '0-0') {
                        alert('한국판 화수 형식이 올바르지 않습니다. (예: 1-1 또는 애X1-1)');
                        return;
                    }
                    Object.assign(newEpisode, {
                        type: 'tv',
                        id: `jp-${jp_ep}`,
                        jp_ep: jp_ep,
                        kr_ep_str: kr_ep_str,
                        kr_season: parsedKr.season,
                        kr_ep: parsedKr.episode,
                        kr_prefix: parsedKr.prefix
                    });
                } else { // movie
                    const movie_order = parseInt(document.getElementById('new-movie-order').value);
                    const movie_season = document.getElementById('new-movie-season').value.trim();
                     if (!movie_order || !movie_season) {
                        alert('극장판 정보를 모두 입력해주세요.');
                        return;
                    }
                    Object.assign(newEpisode, {
                        type: 'movie',
                        id: `movie-${movie_order}`,
                        movie_order: movie_order,
                        jp_ep: 20000 + movie_order,
                        kr_ep_str: movie_season
                    });
                }

                if (episodes.some(ep => ep.id === newEpisode.id)) {
                    alert('이미 존재하는 ID(일본판 화수 또는 작품 순서)입니다.');
                    return;
                }

                episodes.push(newEpisode);
                episodes.sort((a, b) => (a.jp_ep || 0) - (b.jp_ep || 0));
                saveData();
                
                ['new-jp-ep', 'new-kr-ep-str', 'new-movie-order', 'new-movie-season', 'new-title'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.value = '';
                });
                
                addEpisodeForm.classList.add('hidden');
                render();
             }

            function handleToggleEditMode() {
                isEditMode = !isEditMode;
                render();
            }

            function handleDeleteEpisode(id) {
                const episodeToDelete = episodes.find(ep => ep.id === id);
                if (!episodeToDelete) return;
                
                if (confirm(`'${episodeToDelete.title}' 항목을 정말로 삭제하시겠습니까?`)) {
                    episodes = episodes.filter(ep => ep.id !== id);
                    saveData();
                    render();
                }
            }

            function handleDeleteAll() {
                if (confirm('정말로 모든 항목 목록을 영구적으로 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다!')) {
                    episodes = [];
                    saveData();
                    render();
                }
            }

            // --- 이벤트 리스너 등록 ---
            krBtn.addEventListener('click', () => handleViewChange('kr'));
            jpBtn.addEventListener('click', () => handleViewChange('jp'));
            resetBtn.addEventListener('click', handleReset);
            
            exportBtnToggle.addEventListener('click', () => {
                exportOptions.classList.toggle('hidden');
            });

            document.addEventListener('click', (e) => {
                const exportContainer = document.getElementById('export-container');
                if (!exportContainer.contains(e.target)) {
                    exportOptions.classList.add('hidden');
                }
            });

            document.querySelectorAll('.export-format-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const format = e.target.dataset.format;
                    handleExport(format);
                    exportOptions.classList.add('hidden');
                });
            });

            importBtn.addEventListener('click', () => importFileInput.click());
            importFileInput.addEventListener('change', handleImport);
            searchBar.addEventListener('input', (e) => { searchTerm = e.target.value; render(); });
            filterBtns.forEach(btn => btn.addEventListener('click', () => handleFilterChange(btn.dataset.filter)));
            addEpisodeToggle.addEventListener('click', () => addEpisodeForm.classList.toggle('hidden'));
            addEpisodeBtn.addEventListener('click', handleAddEpisode);
            editModeToggle.addEventListener('click', handleToggleEditMode);
            deleteAllBtn.addEventListener('click', handleDeleteAll);

            viewTabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    currentListType = e.target.dataset.viewType;
                    updateAddFormUI();
                    render();
                });
            });

            episodeListContainer.addEventListener('click', (e) => {
                const target = e.target;
                const deleteBtn = target.closest('.delete-episode-btn');
                if (deleteBtn) { handleDeleteEpisode(deleteBtn.dataset.id); return; }
                if (target.matches('.episode-check')) { handleEpisodeCheck(target.dataset.id, target.checked); return; }
                const seasonCheck = target.closest('.season-check');
                if (seasonCheck) { handleSeasonCheck(seasonCheck.dataset.seasonKey, seasonCheck.checked); return; }
                const header = target.closest('.p-3[data-season-key]');
                if (header) { handleAccordionToggle(header.dataset.seasonKey); }
            });

            // --- 초기화 ---
            loadData();
            updateAddFormUI();
            render();
        });
    </script>
</body>
</html>